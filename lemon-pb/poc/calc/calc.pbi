;; This file is automatically generated by LemonPB from input grammar
;; source file "calc.y".
;;
;; 2000-05-29 | 2021-08-02
;;
;; The author disclaims copyright to this source code.  In place of
;; a legal notice, here is a blessing:
;;
;;    May you do good and not evil.
;;    May you find forgiveness for yourself and forgive others.
;;    May you share freely, never taking more than you give.
;;
;;==============================================================================
;; Driver template for the "Lemon PureBasic" parser generator.
;;
;; The "lemon" program processes an LALR(1) input grammar file, then uses
;; this template to construct a parser.  The "lemon" program inserts text
;; at each "%%" line.  Also, any "P-a-r-s-e" identifier prefix (without the
;; interstitial "-" characters) contained in this template is changed into
;; the value of the %name directive from the grammar.  Otherwise, the content
;; of this template is copied straight through into the generate parser
;; source file.
;;
;; The following is the concatenation of all %include directives from the
;; input grammar file:
;;
;-****** Begin %include sections from the grammar ******************************
; NOTE: None of this really needed!
; #line 5 "calc.y"

; #include <stdio.h>
; #include <stdlib.h> /* malloc, free */
; #include "calc.h"
; #line 34 "calc.c"
;******* End of %include directives ********************************************
;  These constants specify the various numeric values for terminal symbols.
;-****** Begin token definitions ***********************************************
; NOTE: Same as in "calc.h":
; #ifndef PLUS
; #define PLUS                            1
; #define MINUS                           2
; #define DIVIDE                          3
; #define TIMES                           4
; #define INTEGER                         5
; #endif

Enumeration TerminalSymbols 1
  #PLUS
  #MINUS
  #DIVIDE
  #TIMES
  #INTEGER
EndEnumeration
;******* End token definitions *************************************************

;; The next sections is a series of control #defines.
;; various aspects of the generated parser.
;;    YYCODETYPE         is the data type used to store the integer codes
;;                       that represent terminal and non-terminal symbols.
;;                       "unsigned char" is used if there are fewer than
;;                       256 symbols.  Larger types otherwise.
;;    YYNOCODE           is a number of type YYCODETYPE that is not used for
;;                       any terminal or nonterminal symbol.
;;    YYFALLBACK         If defined, this indicates that one or more tokens
;;                       (also known as: "terminal symbols") have fall-back
;;                       values which should be used if the original symbol
;;                       would not parse.  This permits keywords to sometimes
;;                       be used as identifiers, for example.
;;    YYACTIONTYPE       is the data type used for "action codes" - numbers
;;                       that indicate what to do in response to the next
;;                       token.
;;    ParseTOKENTYPE     is the data type used for minor type for terminal
;;                       symbols.  Background: A "minor type" is a semantic
;;                       value associated with a terminal or non-terminal
;;                       symbols.  For example, for an "ID" terminal symbol,
;;                       the minor type might be the name of the identifier.
;;                       Each non-terminal can have a different minor type.
;;                       Terminal symbols all have the same minor type, though.
;;                       This macros defines the minor type for terminal
;;                       symbols.
;;    YYMINORTYPE        is the data type used for all minor types.
;;                       This is typically a union of many types, one of
;;                       which is ParseTOKENTYPE.  The entry in the union
;;                       for terminal symbols is called "yy0".
;;    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
;;                       zero the stack is dynamically sized using realloc()
;;    ParseARG_SDECL     A static variable declaration for the %extra_argument
;;    ParseARG_PDECL     A parameter declaration for the %extra_argument
;;    ParseARG_PARAM     Code to pass %extra_argument as a subroutine parameter
;;    ParseARG_STORE     Code to store %extra_argument into yypParser
;;    ParseARG_FETCH     Code to extract %extra_argument from yypParser
;;    ParseCTX_*         As ParseARG_ except for %extra_context
;;    YYERRORSYMBOL      is the code number of the error symbol.  If not
;;                       defined, then do no error processing.
;;    YYNSTATE           the combined number of states.
;;    YYNRULE            the number of rules in the grammar
;;    YYNTOKEN           Number of terminal symbols
;;    YY_MAX_SHIFT       Maximum value for shift actions
;;    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
;;    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
;;    YY_ERROR_ACTION    The yy_action[] code for syntax error
;;    YY_ACCEPT_ACTION   The yy_action[] code for accept
;;    YY_NO_ACTION       The yy_action[] code for no-op
;;    YY_MIN_REDUCE      Minimum value for reduce actions
;;    YY_MAX_REDUCE      Maximum value for reduce actions
;;
; #ifndef Interface
; # Define Interface 1
; #endif
#Interface = #True
;-****** Begin control #defines ************************************************
; #define YYCODETYPE unsigned char
Macro YYCODETYPE
  a
EndMacro
; ----------------------
; #define YYNOCODE 8
#YYNOCODE = 8
; ----------------------
; #define YYACTIONTYPE unsigned char
Macro YYACTIONTYPE
  a
EndMacro
; ----------------------
; TODO: Port Macro for i32 type
; #define ParseTOKENTYPE int
; ----------------------
; TODO: Port YYMINORTYPE Union Structure
; typedef union {
;   int yyinit;
;   ParseTOKENTYPE yy0;
; } YYMINORTYPE;
; ----------------------
; TODO: Port
; #ifndef YYSTACKDEPTH
; #define YYSTACKDEPTH 100
; #endif
; ----------------------
; #define ParseARG_SDECL
; #define ParseARG_PDECL
; #define ParseARG_PARAM
; #define ParseARG_FETCH
; #define ParseARG_STORE
; #define ParseCTX_SDECL
; #define ParseCTX_PDECL
; #define ParseCTX_PARAM
; #define ParseCTX_FETCH
; #define ParseCTX_STORE
#ParseARG_SDECL = #True
#ParseARG_PDECL = #True
#ParseARG_PARAM = #True
#ParseARG_FETCH = #True
#ParseARG_STORE = #True
#ParseCTX_SDECL = #True
#ParseCTX_PDECL = #True
#ParseCTX_PARAM = #True
#ParseCTX_FETCH = #True
#ParseCTX_STORE = #True
; ----------------------
; #define YYNSTATE             8
; #define YYNRULE              6
; #define YYNRULE_WITH_ACTION  6
; #define YYNTOKEN             6
; #define YY_MAX_SHIFT         7
; #define YY_MIN_SHIFTREDUCE   11
; #define YY_MAX_SHIFTREDUCE   16
; #define YY_ERROR_ACTION      17
; #define YY_ACCEPT_ACTION     18
; #define YY_NO_ACTION         19
; #define YY_MIN_REDUCE        20
; #define YY_MAX_REDUCE        25
#YYNSTATE            = 8
#YYNRULE             = 6
#YYNRULE_WITH_ACTION = 6
#YYNTOKEN            = 6
#YY_MAX_SHIFT        = 7
#YY_MIN_SHIFTREDUCE  = 11
#YY_MAX_SHIFTREDUCE  = 16
#YY_ERROR_ACTION     = 17
#YY_ACCEPT_ACTION    = 18
#YY_NO_ACTION        = 19
#YY_MIN_REDUCE       = 20
#YY_MAX_REDUCE       = 25
;******* End control #defines **************************************************
; TODO: Port to Macro
; #define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))

;; Define the yytestcase() macro to be a no-op if is not already defined
;; otherwise.
;;
;; Applications can choose to define yytestcase() in the %include section
;; to a macro that can assist in verifying code coverage.  For production
;; code the yytestcase() macro should be turned off.  But it is useful
;; for testing.
;;
; TODO: Port to Macro
; #ifndef yytestcase
; # define yytestcase(X)
; #endif


;; Next are the tables used to determine what action to take based on the
;; current state and lookahead token.  These tables are used to implement
;; functions that take a state number and lookahead value and return an
;; action integer.
;;
;; Suppose the action integer is N.  Then the action is determined as
;; follows
;;
;;   0 <= N <= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
;;                                      token onto the stack and goto state N.
;;
;;   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
;;     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
;;
;;   N == YY_ERROR_ACTION               A syntax error has occurred.
;;
;;   N == YY_ACCEPT_ACTION              The parser accepts its input.
;;
;;   N == YY_NO_ACTION                  No such action.  Denotes unused
;;                                      slots in the yy_action[] table.
;;
;;   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
;;     and YY_MAX_REDUCE
;;
;; The action table is constructed as a single large table named yy_action[].
;; Given state S and lookahead X, the action is computed as either:
;;
;;    (A)   N = yy_action[ yy_shift_ofst[S] + X ]
;;    (B)   N = yy_default[S]
;;
;; The (A) formula is preferred.  The B formula is used instead if
;; yy_lookahead[yy_shift_ofst[S]+X] is not equal to X.
;;
;; The formulas above are for computing the action when the lookahead is
;; a terminal symbol.  If the lookahead is a non-terminal (as occurs after
;; a reduce action) then the yy_reduce_ofst[] array is used in place of
;; the yy_shift_ofst[] array.
;;
;; The following are the tables generated in this section:
;;
;;  yy_action[]        A single table containing all actions.
;;  yy_lookahead[]     A table containing the lookahead for each entry in
;;                     yy_action.  Used to detect hash collisions.
;;  yy_shift_ofst[]    For each state, the offset into yy_action for
;;                     shifting terminals.
;;  yy_reduce_ofst[]   For each state, the offset into yy_action for
;;                     shifting non-terminals after a reduce.
;;  yy_default[]       Default action for each state.
;;
;-****** Begin parsing tables **************************************************
;! All Lemon generated code is out of order: it had to be reorganized to meet
;! PB needs.

; #define YY_ACTTAB_COUNT (16)
#YY_ACTTAB_COUNT = 16    ; i.e. = 0-15

; ----------------------
;! We convert the static C array to a DataStructure and then use is as a C array
;! from a PB Structured type (only way to use C like arrays). This should make
;! memory access (read only) much faster since data will be stored in the Data
;! section of the binary.

; static const YYACTIONTYPE yy_action[] = {
;  /*     0 */    20,    3,    4,    1,    2,   18,    5,    1,    2,   24,
;  /*    10 */    16,   19,   19,   23,    6,    7,
; };

#YY_LOOKAHEADTAB_COUNT = 22 ; ie. 0-21 TODO: Make Lemon generate this!
; static const YYCODETYPE yy_lookahead[] = {
;  /*     0 */     0,    1,    2,    3,    4,    6,    7,    3,    4,    7,
;  /*    10 */     5,    8,    8,    7,    7,    7,    8,    6,    6,    6,
;  /*    20 */     6,    6,
; };

#YY_REDOFSTTAB_COUNT = 5 ; ie. 0-4 TODO: Make Lemon generate this!
; static const signed char yy_reduce_ofst[] = {
;  /*     0 */    -1,    2,    6,    7,    8,
; };

#YY_DEFAULTTAB_COUNT = 8 ; ie. 0-7 TODO: Make Lemon generate this!
; static const YYACTIONTYPE yy_default[] = {
;  /*     0 */    17,   17,   17,   17,   17,   17,   22,   21,
; };

#YY_SHIFTOFSTTAB_COUNT = 8 ; ie. 0-7 TODO: Make Lemon generate this!
; static const unsigned char yy_shift_ofst[] = {
;  /*     0 */     5,    5,    5,    5,    5,    0,    4,    4,
; };

DataSection
  yyArrTableData:
  ; yy_action[]
  Data.YYACTIONTYPE   20,   3,   4,   1,   2,  18,   5,   1,   2,  24 ;  0
  Data.YYACTIONTYPE   16,  19,  19,  23,   6,   7                     ; 10
  ; yy_lookahead[]:
  Data.YYCODETYPE      0,   1,   2,   3,   4,   6,   7,   3,   4,   7 ; 0
  Data.YYCODETYPE      5,   8,   8,   7,   7,   7,   8,   6,   6,   6 ; 10
  Data.YYCODETYPE      6,   6                                         ; 20
  ; yy_reduce_ofst[]: (always signed char)
  Data.b              -1,   2,   6,   7,   8                          ;  0
  ; yy_default[]:
  Data.YYACTIONTYPE   17,  17,  17,  17,  17,  17,  22,  21           ;  0
  ; yy_shift_ofst[]: (always unsigned char)
  Data.a               5,   5,   5,   5,   5,   0,   4,   4           ;  0
EndDataSection

Structure yyArraysStruct
  action.YYACTIONTYPE[#YY_ACTTAB_COUNT]
  lookahead.YYCODETYPE[#YY_LOOKAHEADTAB_COUNT]
  reduce_ofst.b[#YY_REDOFSTTAB_COUNT]
  default.YYACTIONTYPE[#YY_DEFAULTTAB_COUNT]
  shift_ofst.a[#YY_SHIFTOFSTTAB_COUNT]
EndStructure

*yy.yyArraysStruct = ?yyArrTableData

; ----------------------
; #define YY_SHIFT_COUNT    (7)
; #define YY_SHIFT_MIN      (0)
; #define YY_SHIFT_MAX      (5)
#YY_SHIFT_COUNT = 7
#YY_SHIFT_MIN   = 0
#YY_SHIFT_MAX   = 5
; ----------------------
; #define YY_REDUCE_COUNT (4)
; #define YY_REDUCE_MIN   (-1)
; #define YY_REDUCE_MAX   (8)
#YY_REDUCE_COUNT =  4
#YY_REDUCE_MIN   = -1
#YY_REDUCE_MAX   =  8
;******* End of lemon-generated parsing tables *********************************

CompilerIf #False ;- Skip WIP Code
;; The next table maps tokens (terminal symbols) into fallback tokens.
;; If a construct like the following:
;;
;;      %fallback ID X Y Z.
;;
;; appears in the grammar, then ID becomes a fallback token for X, Y,
;; and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
;; but it does not parse, the type of the token is changed to ID and
;; the parse is retried before an error is thrown.
;;
;; This feature can be used, for example, to cause some keywords in a language
;; to revert to identifiers if they keyword does not apply in the context where
;; it appears.
;;
#ifdef YYFALLBACK
Static const YYCODETYPE yyFallback[] = {
};
#endif /* YYFALLBACK */

;; The following structure represents a single element of the
;; parser's stack.  Information stored includes:
;;
;;   +  The state number for the parser at this level of the stack.
;;
;;   +  The value of the token stored at this level of the stack.
;;      (In other words, the "major" token.)
;;
;;   +  The semantic value stored at this level of the stack.  This is
;;      the information used by the action routines in the grammar.
;;      It is sometimes called the "minor" token.
;;
;; After the "shift" half of a SHIFTREDUCE action, the stateno field
;; actually contains the reduce action for the second half of the
;; SHIFTREDUCE.
;;
; TODO: Port Structure
struct yyStackEntry {
  YYACTIONTYPE stateno;  /* The state-number, or reduce action in SHIFTREDUCE */
  YYCODETYPE major;      /* The major token value.  This is the code
                         ** number For the token at this stack level */
  YYMINORTYPE minor;     /* The user-supplied minor token value.  This
                         ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

;; The state of the parser is completely contained in an instance of
;; the following structure
; TODO: Port Structure
struct yyParser {
  yyStackEntry *yytos;          /* Pointer to top element of the stack */
#ifdef YYTRACKMAXSTACKDEPTH
  int yyhwm;                    /* High-water mark of the stack */
#endif
#ifndef YYNOERRORRECOVERY
  int yyerrcnt;                 /* Shifts left before out of the error */
#endif
  ParseARG_SDECL                /* A place To hold %extra_argument */
  ParseCTX_SDECL                /* A place To hold %extra_context */
#if YYSTACKDEPTH<=0
  int yystksz;                  /* Current side of the stack */
  yyStackEntry *yystack;        /* The parser's stack */
  yyStackEntry yystk0;          /* First stack entry */
#else
  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
  yyStackEntry *yystackEnd;            /* Last entry in the stack */
#endif
};
typedef struct yyParser yyParser;

#ifndef NDEBUG
#include <stdio.h>
#include <assert.h>
Static FILE *yyTraceFILE = 0;
Static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
;;
;; Turn parser tracing on by giving a stream to which to write the trace
;; and a prompt to preface each trace message.  Tracing is turned off
;; by making either argument NULL
;;
;; Inputs:
;;
;;  * A FILE* to which trace output should be written.
;;    If NULL, then tracing is turned off.
;;  * A prefix string written at the beginning of every
;;    line of trace output.  If NULL, then tracing is
;;    turned off.
;;
;; Outputs:
;; None.
;;
; TODO: Port Procedure
void ParseTrace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  If( yyTraceFILE==0 ) yyTracePrompt = 0;
  Else If( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#if Defined(YYCOVERAGE) || !Defined(NDEBUG)
;; For tracing shifts, the names of all terminals and nonterminals
;; are required.  The following table supplies these names */
; TODO: Port Array
Static const char *const yyTokenName[] = {
  /*    0 */ "$",
  /*    1 */ "PLUS",
  /*    2 */ "MINUS",
  /*    3 */ "DIVIDE",
  /*    4 */ "TIMES",
  /*    5 */ "INTEGER",
  /*    6 */ "program",
  /*    7 */ "expr",
};
#endif /* Defined(YYCOVERAGE) || !Defined(NDEBUG) */

#ifndef NDEBUG
;; For tracing reduce actions, the names of all rules are required.
;;
; TODO: Port Array
Static const char *const yyRuleName[] = {
 /*   0 */ "program ::= expr",
 /*   1 */ "expr ::= expr MINUS expr",
 /*   2 */ "expr ::= expr PLUS expr",
 /*   3 */ "expr ::= expr TIMES expr",
 /*   4 */ "expr ::= expr DIVIDE expr",
 /*   5 */ "expr ::= INTEGER",
};
#endif /* NDEBUG */


#if YYSTACKDEPTH<=0
;;
;; Try to increase the size of the parser stack.  Return the number
;; of errors.  Return 0 on success.
;;
Static int yyGrowStack(yyParser *p){
  int newSize;
  int idx;
  yyStackEntry *pNew;

  newSize = p->yystksz*2 + 100;
  idx = p->yytos ? (int)(p->yytos - p->yystack) : 0;
  If( p->yystack==&p->yystk0 ){
    pNew = malloc(newSize*SizeOf(pNew[0]));
    If( pNew ) pNew[0] = p->yystk0;
  }Else{
    pNew = realloc(p->yystack, newSize*SizeOf(pNew[0]));
  }
  If( pNew ){
    p->yystack = pNew;
    p->yytos = &p->yystack[idx];
#ifndef NDEBUG
    If( yyTraceFILE ){
      fprintf(yyTraceFILE,"%sStack grows from %d to %d entries.\n",
              yyTracePrompt, p->yystksz, newSize);
    }
#endif
    p->yystksz = newSize;
  }
  Return pNew==0;
}
#endif

;; Datatype of the argument to the memory allocated passed as the
;; second argument to ParseAlloc() below.  This can be changed by
;; putting an appropriate #define in the %include section of the input
;; grammar.
;;
; TODO: Port Macro
#ifndef YYMALLOCARGTYPE
# Define YYMALLOCARGTYPE size_t
#endif

;; Initialize a new parser that has already been allocated.
;;
void ParseInit(void *yypRawParser ParseCTX_PDECL){
  yyParser *yypParser = (yyParser*)yypRawParser;
  ParseCTX_STORE
#ifdef YYTRACKMAXSTACKDEPTH
  yypParser->yyhwm = 0;
#endif
#if YYSTACKDEPTH<=0
  yypParser->yytos = NULL;
  yypParser->yystack = NULL;
  yypParser->yystksz = 0;
  If( yyGrowStack(yypParser) ){
    yypParser->yystack = &yypParser->yystk0;
    yypParser->yystksz = 1;
  }
#endif
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = 0;
  yypParser->yystack[0].major = 0;
#if YYSTACKDEPTH>0
  yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];
#endif
}

#ifndef Parse_ENGINEALWAYSONSTACK
;;
;; This function allocates a new parser.
;; The only argument is a pointer to a function which works like
;; malloc.
;;
;; Inputs:
;; A pointer to the function used to allocate memory.
;;
;; Outputs:
;; A pointer to a parser.  This pointer is used in subsequent calls
;; to Parse and ParseFree.
;;
void *ParseAlloc(void *(*mallocProc)(YYMALLOCARGTYPE) ParseCTX_PDECL){
  yyParser *yypParser;
  yypParser = (yyParser*)(*mallocProc)( (YYMALLOCARGTYPE)SizeOf(yyParser) );
  If( yypParser ){
    ParseCTX_STORE
    ParseInit(yypParser ParseCTX_PARAM);
  }
  Return (void*)yypParser;
}
#endif /* Parse_ENGINEALWAYSONSTACK */


;; The following function deletes the "minor type" or semantic value
;; associated with a symbol.  The symbol can be either a terminal
;; or nonterminal. "yymajor" is the symbol code, and "yypminor" is
;; a pointer to the value to be deleted.  The code used to do the
;; deletions is derived from the %destructor and/or %token_destructor
;; directives of the input grammar.
;;
Static void yy_destructor(
  yyParser *yypParser,    /* The parser */
  YYCODETYPE yymajor,     /* Type code For object To destroy */
  YYMINORTYPE *yypminor   /* The object To be destroyed */
){
  ParseARG_FETCH
  ParseCTX_FETCH
  switch( yymajor ){
    ;; Here is inserted the actions which take place when a
    ;; terminal or non-terminal is destroyed.  This can happen
    ;; when the symbol is popped from the stack during a
    ;; reduce or during error processing or when a parser is
    ;; being destroyed before it is finished parsing.
    ;;
    ;; Note: during a reduce, the only symbols destroyed are those
    ;; which appear on the RHS of the rule, but which are *not* used
    ;; inside the C code.
    ;;
;-****** Begin destructor definitions ******************************************
;******* End destructor definitions ********************************************
    Default:  Break;   /* If no destructor action specified: do nothing */
  }
}

;;
;; Pop the parser's stack once.
;;
;; If there is a destructor routine associated with the token which
;; is popped from the stack, then call it.
;;
; TODO: Port Procedure
Static void yy_pop_parser_stack(yyParser *pParser){
  yyStackEntry *yytos;
  assert( pParser->yytos!=0 );
  assert( pParser->yytos > pParser->yystack );
  yytos = pParser->yytos--;
#ifndef NDEBUG
  If( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yy_destructor(pParser, yytos->major, &yytos->minor);
}

;;
;; Clear all secondary memory allocations from the parser
;;
; TODO: Port Procedure
void ParseFinalize(void *p){
  yyParser *pParser = (yyParser*)p;
  While( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);
#if YYSTACKDEPTH<=0
  If( pParser->yystack!=&pParser->yystk0 ) free(pParser->yystack);
#endif
}

#ifndef Parse_ENGINEALWAYSONSTACK
;;
;; Deallocate and destroy a parser.  Destructors are called for
;; all stack elements before shutting the parser down.
;;
;; If the YYPARSEFREENEVERNULL macro exists (for example because it
;; is defined in a %include section of the input grammar) then it is
;; assumed that the input pointer is never NULL.
;;
; TODO: Port Procedure
void ParseFree(
  void *p,                    /* The parser To be deleted */
  void (*freeProc)(void*)     /* Function used To reclaim memory */
){
#ifndef YYPARSEFREENEVERNULL
  If( p==0 ) Return;
#endif
  ParseFinalize(p);
  (*freeProc)(p);
}
#endif /* Parse_ENGINEALWAYSONSTACK */

;;
;; Return the peak depth of the stack for a parser.
;;
#ifdef YYTRACKMAXSTACKDEPTH
int ParseStackPeak(void *p){
  yyParser *pParser = (yyParser*)p;
  Return pParser->yyhwm;
}
#endif

;; This array of booleans keeps track of the parser statement
;; coverage.  The element yycoverage[X][Y] is set when the parser
;; is in state X and has a lookahead token Y.  In a well-tested
;; systems, every element of this matrix should end up being set.
;;
#if Defined(YYCOVERAGE)
Static unsigned char yycoverage[YYNSTATE][YYNTOKEN];
#endif

;;
;; Write into out a description of every state/lookahead combination that
;;
;;   (1)  has not been used by the parser, and
;;   (2)  is not a syntax error.
;;
;; Return the number of missed state/lookahead combinations.
;;
#if Defined(YYCOVERAGE)
int ParseCoverage(FILE *out){
  int stateno, iLookAhead, i;
  int nMissed = 0;
  For(stateno=0; stateno<YYNSTATE; stateno++){
    i = yy_shift_ofst[stateno];
    For(iLookAhead=0; iLookAhead<YYNTOKEN; iLookAhead++){
      If( yy_lookahead[i+iLookAhead]!=iLookAhead ) Continue;
      If( yycoverage[stateno][iLookAhead]==0 ) nMissed++;
      If( out ){
        fprintf(out,"State %d lookahead %s %s\n", stateno,
                yyTokenName[iLookAhead],
                yycoverage[stateno][iLookAhead] ? "ok" : "missed");
      }
    }
  }
  Return nMissed;
}
#endif

;;
;; Find the appropriate action for a parser given the terminal
;; look-ahead token iLookAhead.
;;
Static YYACTIONTYPE yy_find_shift_action(
  YYCODETYPE iLookAhead,    /* The look-ahead token */
  YYACTIONTYPE stateno      /* Current state number */
){
  int i;

  If( stateno>YY_MAX_SHIFT ) Return stateno;
  assert( stateno <= YY_SHIFT_COUNT );
#if Defined(YYCOVERAGE)
  yycoverage[stateno][iLookAhead] = 1;
#endif
  do{
    i = yy_shift_ofst[stateno];
    assert( i>=0 );
    assert( i<=YY_ACTTAB_COUNT );
    assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );
    assert( iLookAhead!=YYNOCODE );
    assert( iLookAhead < YYNTOKEN );
    i += iLookAhead;
    assert( i<(int)YY_NLOOKAHEAD );
    If( yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
      YYCODETYPE iFallback;            /* Fallback token */
      assert( iLookAhead<SizeOf(yyFallback)/SizeOf(yyFallback[0]) );
      iFallback = yyFallback[iLookAhead];
      If( iFallback!=0 ){
#ifndef NDEBUG
        If( yyTraceFILE ){
          fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
             yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
        }
#endif
        assert( yyFallback[iFallback]==0 ); /* Fallback loop must terminate */
        iLookAhead = iFallback;
        Continue;
      }
#endif
#ifdef YYWILDCARD
      {
        int j = i - iLookAhead + YYWILDCARD;
        assert( j<(int)(SizeOf(yy_lookahead)/SizeOf(yy_lookahead[0])) );
        If( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){
#ifndef NDEBUG
          If( yyTraceFILE ){
            fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
               yyTracePrompt, yyTokenName[iLookAhead],
               yyTokenName[YYWILDCARD]);
          }
#endif /* NDEBUG */
          Return yy_action[j];
        }
      }
#endif /* YYWILDCARD */
      Return yy_default[stateno];
    }Else{
      assert( i>=0 && i<(int)(SizeOf(yy_action)/SizeOf(yy_action[0])) );
      Return yy_action[i];
    }
  }While(1);
}

;;
;; Find the appropriate action for a parser given the non-terminal
;; look-ahead token iLookAhead.
;;
Static YYACTIONTYPE yy_find_reduce_action(
  YYACTIONTYPE stateno,     /* Current state number */
  YYCODETYPE iLookAhead     /* The look-ahead token */
){
  int i;
#ifdef YYERRORSYMBOL
  If( stateno>YY_REDUCE_COUNT ){
    Return yy_default[stateno];
  }
#else
  assert( stateno<=YY_REDUCE_COUNT );
#endif
  i = yy_reduce_ofst[stateno];
  assert( iLookAhead!=YYNOCODE );
  i += iLookAhead;
#ifdef YYERRORSYMBOL
  If( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){
    Return yy_default[stateno];
  }
#else
  assert( i>=0 && i<YY_ACTTAB_COUNT );
  assert( yy_lookahead[i]==iLookAhead );
#endif
  Return yy_action[i];
}

;;
;; The following routine is called if the stack overflows.
;;
Static void yyStackOverflow(yyParser *yypParser){
   ParseARG_FETCH
   ParseCTX_FETCH
#ifndef NDEBUG
   If( yyTraceFILE ){
     fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
   }
#endif
   While( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
   /* Here code is inserted which will execute If the parser
   ** stack every overflows */
;-****** Begin %stack_overflow code ********************************************
;******* End %stack_overflow code **********************************************
   ParseARG_STORE /* Suppress warning about unused %extra_argument var */
   ParseCTX_STORE
}

;;
;; Print tracing information for a SHIFT action
;;
#ifndef NDEBUG
Static void yyTraceShift(yyParser *yypParser, int yyNewState, const char *zTag){
  If( yyTraceFILE ){
    If( yyNewState<YYNSTATE ){
      fprintf(yyTraceFILE,"%s%s '%s', go to state %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState);
    }Else{
      fprintf(yyTraceFILE,"%s%s '%s', pending reduce %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState - YY_MIN_REDUCE);
    }
  }
}
#else
# Define yyTraceShift(X,Y,Z)
#endif

;;
;; Perform a shift action.
;;
Static void yy_shift(
  yyParser *yypParser,          /* The parser To be shifted */
  YYACTIONTYPE yyNewState,      /* The new state To shift in */
  YYCODETYPE yyMajor,           /* The major token To shift in */
  ParseTOKENTYPE yyMinor        /* The minor token To shift in */
){
  yyStackEntry *yytos;
  yypParser->yytos++;
#ifdef YYTRACKMAXSTACKDEPTH
  If( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
    yypParser->yyhwm++;
    assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );
  }
#endif
#if YYSTACKDEPTH>0
  If( yypParser->yytos>yypParser->yystackEnd ){
    yypParser->yytos--;
    yyStackOverflow(yypParser);
    Return;
  }
#else
  If( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz] ){
    If( yyGrowStack(yypParser) ){
      yypParser->yytos--;
      yyStackOverflow(yypParser);
      Return;
    }
  }
#endif
  If( yyNewState > YY_MAX_SHIFT ){
    yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
  }
  yytos = yypParser->yytos;
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
  yyTraceShift(yypParser, yyNewState, "Shift");
}

;; For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
;; of that rule
Static const YYCODETYPE yyRuleInfoLhs[] = {
     6,  /* (0) program ::= expr */
     7,  /* (1) expr ::= expr MINUS expr */
     7,  /* (2) expr ::= expr PLUS expr */
     7,  /* (3) expr ::= expr TIMES expr */
     7,  /* (4) expr ::= expr DIVIDE expr */
     7,  /* (5) expr ::= INTEGER */
};

;; For rule J, yyRuleInfoNRhs[J] contains the negative of the number
;; of symbols on the right-hand side of that rule.
Static const signed char yyRuleInfoNRhs[] = {
   -1,  /* (0) program ::= expr */
   -3,  /* (1) expr ::= expr MINUS expr */
   -3,  /* (2) expr ::= expr PLUS expr */
   -3,  /* (3) expr ::= expr TIMES expr */
   -3,  /* (4) expr ::= expr DIVIDE expr */
   -1,  /* (5) expr ::= INTEGER */
};

Static void yy_accept(yyParser*);  /* Forward Declaration */

;;
;; Perform a reduce action and the shift that must immediately
;; follow the reduce.
;;
;; The yyLookahead and yyLookaheadToken parameters provide reduce actions
;; access to the lookahead token (if any).  The yyLookahead will be YYNOCODE
;; if the lookahead token has already been consumed.  As this procedure is
;; only called from one place, optimizing compilers will in-line it, which
;; means that the extra parameters have no performance impact.
;;
Static YYACTIONTYPE yy_reduce(
  yyParser *yypParser,         /* The parser */
  unsigned int yyruleno,       /* Number of the rule by which To reduce */
  int yyLookahead,             /* Lookahead token, Or YYNOCODE If none */
  ParseTOKENTYPE yyLookaheadToken  /* Value of the lookahead token */
  ParseCTX_PDECL                   /* %extra_context */
){
  int yygoto;                     /* The next state */
  YYACTIONTYPE yyact;             /* The next action */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  ParseARG_FETCH
  (void)yyLookahead;
  (void)yyLookaheadToken;
  yymsp = yypParser->yytos;

  switch( yyruleno ){
  ;; Beginning here are the reduction cases.  A typical example
  ;; follows:
  ;;   case 0:
  ;  #line <lineno> <grammarfile>
  ;;     { ... }           // User supplied code
  ;  #line <lineno> <thisfile>
  ;;     break;
  ;;
;-****** Begin reduce actions **************************************************
        YYMINORTYPE yylhsminor;
      Case 0: /* program ::= expr */
; #line 20 "calc.y"
{
    printf ("Result=%d\n", yymsp[0].minor.yy0);
}
; #line 825 "calc.c"
        Break;
      Case 1: /* expr ::= expr MINUS expr */
; #line 24 "calc.y"
{
    yylhsminor.yy0 = yymsp[-2].minor.yy0 - yymsp[0].minor.yy0;
}
; #line 832 "calc.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        Break;
      Case 2: /* expr ::= expr PLUS expr */
; #line 28 "calc.y"
{
    yylhsminor.yy0 = yymsp[-2].minor.yy0 + yymsp[0].minor.yy0;
}
; #line 840 "calc.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        Break;
      Case 3: /* expr ::= expr TIMES expr */
; #line 32 "calc.y"
{
    yylhsminor.yy0 = yymsp[-2].minor.yy0 * yymsp[0].minor.yy0;
}
; #line 848 "calc.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        Break;
      Case 4: /* expr ::= expr DIVIDE expr */
; #line 36 "calc.y"
{
    If (yymsp[0].minor.yy0 != 0) {
        yylhsminor.yy0 = yymsp[-2].minor.yy0 / yymsp[0].minor.yy0;
    } Else {
        printf ("yylhsminor.yy0 divide by zero detected\n");
    }
}
; #line 860 "calc.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        Break;
      Case 5: /* expr ::= INTEGER */
; #line 44 "calc.y"
{
    yylhsminor.yy0 = yymsp[0].minor.yy0;
}
; #line 868 "calc.c"
  yymsp[0].minor.yy0 = yylhsminor.yy0;
        Break;
      Default:
        Break;
;******* End reduce actions ****************************************************
  };
  assert( yyruleno<SizeOf(yyRuleInfoLhs)/SizeOf(yyRuleInfoLhs[0]) );
  yygoto = yyRuleInfoLhs[yyruleno];
  yysize = yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);

  ;; There are no SHIFTREDUCE actions on nonterminals because the table
  ;; generator has simplified them to pure REDUCE actions.
  assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );

  ; It is not possible for a REDUCE to be followed by an error
  assert( yyact!=YY_ERROR_ACTION );

  yymsp += yysize+1;
  yypParser->yytos = yymsp;
  yymsp->stateno = (YYACTIONTYPE)yyact;
  yymsp->major = (YYCODETYPE)yygoto;
  yyTraceShift(yypParser, yyact, "... then shift");
  Return yyact;
}

;;
;; The following code executes when the parse fails
;;
#ifndef YYNOERRORRECOVERY
Static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#ifndef NDEBUG
  If( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  While( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
  ;; Here code is inserted which will be executed whenever the
  ;; parser fails
;-****** Begin %parse_failure code *********************************************
;******* End %parse_failure code ***********************************************
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}
#endif /* YYNOERRORRECOVERY */

;;
;; The following code executes when a syntax error first occurs.
;;
Static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  ParseTOKENTYPE yyminor         /* The minor type of the error token */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#define TOKEN yyminor
;-****** Begin %syntax_error code **********************************************
; #line 16 "calc.y"

    printf ("Syntax error!\n");
; #line 934 "calc.c"
;******* End %syntax_error code ************************************************
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}

;;
;; The following is executed when the parser accepts
;;
Static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#ifndef NDEBUG
  If( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  assert( yypParser->yytos==yypParser->yystack );
  ;; Here code is inserted which will be executed whenever the
  ;; parser accepts
;-****** Begin %parse_accept code **********************************************
;******* End %parse_accept code ************************************************
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}

;; The main parser program.
;; The first argument is a pointer to a structure obtained from
;; "ParseAlloc" which describes the current state of the parser.
;; The second argument is the major token number.  The third is
;; the minor token.  The fourth optional argument is whatever the
;; user wants (and specified in the grammar) and is available for
;; use by the action routines.
;;
;; Inputs:
;;
;;  * A pointer to the parser (an opaque structure.)
;;  * The major token number.
;;  * The minor token number.
;;  * An option argument of a grammar-specified type.
;;
;; Outputs:
;; None.
;;
void Parse(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  ParseTOKENTYPE yyminor       /* The value For the token */
  ParseARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  YYACTIONTYPE yyact;   /* The parser action. */
#if !Defined(YYERRORSYMBOL) && !Defined(YYNOERRORRECOVERY)
  int yyendofinput;     /* True if we are at the end of input */
#endif
#ifdef YYERRORSYMBOL
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
#endif
  yyParser *yypParser = (yyParser*)yyp;  /* The parser */
  ParseCTX_FETCH
  ParseARG_STORE

  assert( yypParser->yytos!=0 );
#if !Defined(YYERRORSYMBOL) && !Defined(YYNOERRORRECOVERY)
  yyendofinput = (yymajor==0);
#endif

  yyact = yypParser->yytos->stateno;
#ifndef NDEBUG
  If( yyTraceFILE ){
    If( yyact < YY_MIN_REDUCE ){
      fprintf(yyTraceFILE,"%sInput '%s' in state %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact);
    }Else{
      fprintf(yyTraceFILE,"%sInput '%s' with pending reduce %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact-YY_MIN_REDUCE);
    }
  }
#endif

  While(1){ /* Exit by "break" */
    assert( yypParser->yytos>=yypParser->yystack );
    assert( yyact==yypParser->yytos->stateno );
    yyact = yy_find_shift_action((YYCODETYPE)yymajor,yyact);
    If( yyact >= YY_MIN_REDUCE ){
      unsigned int yyruleno = yyact - YY_MIN_REDUCE; /* Reduce by this rule */
      assert( yyruleno<(int)(SizeOf(yyRuleName)/SizeOf(yyRuleName[0])) );
#ifndef NDEBUG
      If( yyTraceFILE ){
        int yysize = yyRuleInfoNRhs[yyruleno];
        If( yysize ){
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",
            yyTracePrompt,
            yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action",
            yypParser->yytos[yysize].stateno);
        }Else{
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s.\n",
            yyTracePrompt, yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action");
        }
      }
#endif /* NDEBUG */

      ;; Check that the stack is large enough to grow by a single entry
      ;; if the RHS of the rule is empty.  This ensures that there is room
      ;; enough on the stack to push the LHS value
      If( yyRuleInfoNRhs[yyruleno]==0 ){
#ifdef YYTRACKMAXSTACKDEPTH
        If( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
          yypParser->yyhwm++;
          assert( yypParser->yyhwm ==
                  (int)(yypParser->yytos - yypParser->yystack));
        }
#endif
#if YYSTACKDEPTH>0
        If( yypParser->yytos>=yypParser->yystackEnd ){
          yyStackOverflow(yypParser);
          Break;
        }
#else
        If( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){
          If( yyGrowStack(yypParser) ){
            yyStackOverflow(yypParser);
            Break;
          }
        }
#endif
      }
      yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor ParseCTX_PARAM);
    }Else If( yyact <= YY_MAX_SHIFTREDUCE ){
      yy_shift(yypParser,yyact,(YYCODETYPE)yymajor,yyminor);
#ifndef YYNOERRORRECOVERY
      yypParser->yyerrcnt--;
#endif
      Break;
    }Else If( yyact==YY_ACCEPT_ACTION ){
      yypParser->yytos--;
      yy_accept(yypParser);
      Return;
    }Else{
      assert( yyact == YY_ERROR_ACTION );
      yyminorunion.yy0 = yyminor;
#ifdef YYERRORSYMBOL
      int yymx;
#endif
#ifndef NDEBUG
      If( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      ;; A syntax error has occurred.
      ;; The response to an error depends upon whether or not the
      ;; grammar defines an error token "ERROR".
      ;;
      ;; This is what we do if the grammar does define ERROR:
      ;;
      ;;  * Call the %syntax_error function.
      ;;
      ;;  * Begin popping the stack until we enter a state where
      ;;    it is legal to shift the error symbol, then shift
      ;;    the error symbol.
      ;;
      ;;  * Set the error count to three.
      ;;
      ;;  * Begin accepting and shifting new tokens.  No new error
      ;;    processing will occur until three tokens have been
      ;;    shifted successfully.
      ;;
      ;;
      If( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminor);
      }
      yymx = yypParser->yytos->major;
      If( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        If( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
        yymajor = YYNOCODE;
      }Else{
        While( yypParser->yytos >= yypParser->yystack
            && (yyact = yy_find_reduce_action(
                        yypParser->yytos->stateno,
                        YYERRORSYMBOL)) > YY_MAX_SHIFTREDUCE
        ){
          yy_pop_parser_stack(yypParser);
        }
        If( yypParser->yytos < yypParser->yystack || yymajor==0 ){
          yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
          yypParser->yyerrcnt = -1;
#endif
          yymajor = YYNOCODE;
        }Else If( yymx!=YYERRORSYMBOL ){
          yy_shift(yypParser,yyact,YYERRORSYMBOL,yyminor);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
      If( yymajor==YYNOCODE ) Break;
      yyact = yypParser->yytos->stateno;
#elif Defined(YYNOERRORRECOVERY)
      ;; If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ;; do any kind of error recovery.  Instead, simply invoke the syntax
      ;; error routine and continue going as if nothing had happened.
      ;;
      ;; Applications can set this macro (for example inside %include) if
      ;; they intend to abandon the parse upon the first syntax error seen.
      ;;
      yy_syntax_error(yypParser,yymajor, yyminor);
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      Break;
#else  /* YYERRORSYMBOL is Not defined */
      ;; This is what we do if the grammar does not define ERROR:
      ;;
      ;;  * Report an error message, and throw away the input token.
      ;;
      ;;  * If the input token is $, then fail the parse.
      ;;
      ;; As before, subsequent error messages are suppressed until
      ;; three input tokens have been successfully shifted.
      ;;
      If( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor, yyminor);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      If( yyendofinput ){
        yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
        yypParser->yyerrcnt = -1;
#endif
      }
      Break;
#endif
    }
  }
#ifndef NDEBUG
  If( yyTraceFILE ){
    yyStackEntry *i;
    char cDiv = '[';
    fprintf(yyTraceFILE,"%sReturn. Stack=",yyTracePrompt);
    For(i=&yypParser->yystack[1]; i<=yypParser->yytos; i++){
      fprintf(yyTraceFILE,"%c%s", cDiv, yyTokenName[i->major]);
      cDiv = ' ';
    }
    fprintf(yyTraceFILE,"]\n");
  }
#endif
  Return;
}

;;
;; Return the fallback token corresponding to canonical token iToken, or
;; 0 if iToken has no fallback.
;;
int ParseFallback(int iToken){
#ifdef YYFALLBACK
  assert( iToken<(int)(SizeOf(yyFallback)/SizeOf(yyFallback[0])) );
  Return yyFallback[iToken];
#else
  (void)iToken;
  Return 0;
#endif
}
/*
** The author of this program disclaims copyright.
*/

int main()
{
    void* pParser = ParseAlloc (malloc);

    /* First input:
    ** 15 / 5
    */
    Parse (pParser, INTEGER, 15);
    Parse (pParser, DIVIDE, 0);
    Parse (pParser, INTEGER, 5);
    Parse (pParser, 0, 0);

    /* Second input:
    ** 50 + 125
    */
    Parse (pParser, INTEGER, 50);
    Parse (pParser, PLUS, 0);
    Parse (pParser, INTEGER, 125);
    Parse (pParser, 0, 0);

    /* Third input:
    ** 50 * 125 + 125
    */
    Parse (pParser, INTEGER, 50);
    Parse (pParser, TIMES, 0);
    Parse (pParser, INTEGER, 125);
    Parse (pParser, PLUS, 0);
    Parse (pParser, INTEGER, 125);
    Parse (pParser, 0, 0);

    ParseFree(pParser, free);

    Return 0;
}

/* Local Variables: */
/* c-basic-offset: 4 */
/* tab-width: 4 */
/* indent-tabs-mode: t */
/* End: */
CompilerEndIf ;- End Skip WIP Code

